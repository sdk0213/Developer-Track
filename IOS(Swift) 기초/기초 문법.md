### 변수 및 상수
* 변수
  * var (kotlin var)
* 상수
  * let (kotlin val)
---
### 타입 엄격함 + 타입 추론 해줌(kotlin 과 비슷)
* ```swift
  //             (type)
  let birthyear: Int = 1994
* 형변환 (swift vs kotlin vs java)
  * swift
    ```swift
    Float(birthyear) 
  * kotlin
    ```kotlin
    birthyear as Float
  * java
    ```java
    (float)birthyear
---
### 집단 자료형  (이외 추가 필요 -> 튜플(Tuple), Collection 과 같은 기능 또는 클래스/객체
#### 1. Array
* 선언
  ```swift
  // init 1
  var languages: [String] = []
  // init 2
  var languages = [String]( )
  // init 3
  var languages:String = [ ]
  // init 4
  var languages = ["Swift", "Objective-C", "Python"]
  // init 5
  var languages:[String] = ["Swift", "Objective-C", "Python"]
  // init 6
  var languages : Array<String> = []
  // init 7 (immutable 이 아닌 단순히 size 만 정해서 동적배열을 생성하는것)
  var languages = [String](repeating: "C", count: 3) // ["C", "C", "C"]
* 수정
  ```swift
  var arr : Array<Int> = [1,2,3,4]
  arr[1...2] // [2,3]
  arr[1...2] = [5,6,7,8,9] 
  print(arr) //[1,5,6,7,8,4]

* 추가
  ```swift
  var languages : Array<String> = []
  languages.append("Swift");
  languages.append(contentsOf: ["Objective-C", "Python"])
  languages.insert("Java", at: 1)
  // languages.insert(contentsOf: ["Java", "Kotlin"], at: 0)
  // ["Swift" "Java" "Objective-C" "Python"]
  
* 삭제
  ```swift
  languages.remove(at: 0
  languages.popLast() // --> return nil
  languages.removeLast() // --> return error
  
#### 2. dictionary (== Map)
* java, kotlin 의 Map 과 같은 개념인것으로 추정
* ```swift
  // init 1
  var capitals: [String: String] = [:]
  // init 2
  var capitals = [ "한국": "서울", "일본": "도쿄", "중국": "베이징", ]
  // init 3
  var responseMessage: [Int: String] = [200: "OK", 403: "Access Forbidden"]
  responseMessage[200] = "Connection Is OK"
  print(responseMessage[200])
 
  responseMessage[200] = nil
  print(reponseMessage[200])
 
#### 3. Set
* 말그대로 set 이다.
* ```swift
  var strs = Set<String>("A", "B", "C", "D")
  strs = [] // make emtpy
 
  strs.insert("E")
  strs.remove("B")
  strs.contains("B") // return boolean

---
### 조건문
#### 1. if
* 단순조건
  ```swift
  var num: Int = 2
  
  if num % 2 == 0 {
      print("2로 나누어짐")
  } else if num % 3 != 0 {
      print("3로 나누어짐")
  } else {
      print("Else")
  }
* nil 체크
  ```swift
  let data: String? = "nilableString"
  
  if let str = data {
      print("data :: \(str)")
  } else {
      print("data is nil")
  }
  
#### 2. guard
* 조건이 아니면 실행
* 방어코드(guard code?) 라고 읽으면 if(false) 체크할때보다 가독성이 좋다고는 하는데 사실 잘 모르겠다. 어짜피 return 시키는 코드의 작성이라면 if 문으로도 가능하기 때문이다.
* ```swift
  // is bool nil ?
  // is bool false
  func guardExample(_ testBool: Bool?) {
      guard let bool = testBool, bool else {
          print("참이 아니다.")
          return
      }

      print("result bool :: \(bool)")
  }
  
  func printMessage(_ message: String?) {
      // 이 밑으로는 message 가 nil 아닌 경우만 존재해야함.. 이 외에는 전부다 방어함(guard)
      guard message != nil else { return }
          print(message!)
  }
  
#### 3. switch
* ```swift
  var word: String = "D"
  
  switch word {
  case "A"..."Z":
      print("대문자")
  case "a"..."z":
      print("소문자")
  default:
      print("이건 뭐야?")
  }
  
#### 4. 삼항연산자
* ```swift
  let myAge: Int = 29
  
  myAge >= 30 ? print("나이를 많이 드셨네요?") : print("아직 젊네요?")
  
---
### Optional
* kotlin 의 nullable ('?' 사용) 또는 java 에서의 Optional 과 비슷한 개념같다.
#### Optional
* ? 가 붙을경우 nilable 로 nil 이 허용된다. 다만 Optional 이라는 값이 붙는다.
  * ```swift
    var email: String? print(email) // nil 
    email = "hh940630@gmail.com" 
    
    print(email) // Optional("hh940630@gmail.com") // <----- Optional 이라는 값이 포함됨
* Optional 과 Non-Optional 은 서로 변수에 넣는것이 불가하다.
  * ```swift
    let optionalEmail: String? = "hh940630@gmail.com" 
    let requiredEmail: String = optionalEmail // Compile Error

#### Optional Binding
* Optional 을 체크하여 Optional을 벗길수있다.
* ```swift
  var optionalName: String? = "Mark" 
  var optionalEmail: String? = "hh940630@gmail.com" 
  if let name = optionalName, email = optionalEmail { 
      // name과 email 값이 존재 
  }
  
  // 또는 아래와 같이 조건을 추가적으로 검사 가능
  if let age = optionalAge, age >= 20 { 
      // age의 값이 존재하고, 20 이상입니다. 
  }
* ```swift
  // Optional type으로 선언한 myNumber
  let myNumber: Int? = 1234
  if let actualNumber = myNumber {
   print(“\(myNumber)은 실제로 \(actualNumber)입니다.”)
  } else {
   print(“\(myNumber)는 변환될 수 없습니다.”)
  }
  // 출력 결과 : Optional(1234)은 실제로 1234입니다.
  print(actualNumber) // error
  
#### Optional Chaning 
* kotlin 의 '?' Chaning 이다.
* ```swift
  let isEmptyArray = array?.isEmpty == true
  
#### Implicitly Unwrapped Optional
* kotlin 의 '!!' 이다.  
* kotlin 에서와 같이 역시나 되도록 사용 하지 않도록하기
* ```swift
  var email: String! = "hh940630@gmail.com" 
  print(email) // hh940630@gmail.com
  
  var email: String! 
  print(email) // Runtime Error!
