
# 정렬이란 대소관계를 따져 일정한 순서로 줄지어 세우는것
-----
# 종류
---
### 버블(bubble)
* 두 개씩 앞에서부터 비교
* for 문 두개 사용하는 단순 무식 하지만 뇌는 편함
* 특징
  * 시간복잡도 -> O(n^{2})
---
### 선택(selecton)
* 선형탐색후 왼쪽 끝자리랑 비교 -> 왼쪽 끝자리 제외하고 선형탐색후 비교 until.. 끝까지
* 특징
  * 시간복잡도 -> O(n^{2})
---
### 삽입(insertion)
* 1 비교 -> 1, 2 비교 -> 1, 2, 3 비교 -> .... 1 .. , n 비교함
* 비교하면서 자기 보다 작은 숫자가 나올때까지 서로 바꾼다.
* 특징
  * 시간복잡도 -> O(n^{2})
---
### 힙(heap)
* 힙에다가 전부 넣는다(힙구조를 유지하며) -> 꺼낸다(힙구조를 유지하며)
* 실제 구현은 배열로 처리함
* 특징
  * 시간복잡도 -> O(NlonN)
  * 실제 시간을 측정 시 퀵정렬보다 느림
---
### 병합(merge)
* 수열을 전부 다 반씩 분할한다 -> 아래서부터 병합한다.
* 병합되는 시점에 정렬을한다.
* 특징 
  * 시간복잡도 -> O(NlonN)
  * 추가적인 메모리 필요함
---
### 퀵(quick)
---
* 피봇을 맨 오른쪽에다가 둠
* 피봇을 기준으로 왼쪽에 마커를 두는데 두개 두는데 맨 왼쪽 끝,맨 오른쪽 끝(피봇바로 왼쪽)에 둠
* 왼쪽마커는 오른쪽으로 이동, 오른쪽 마커는 왼쪽으로 이동함
* 왼쪽마커는 피봇보다 큰수를 찾으면 멈추고 오른쪽 마커는 피봇보다 작은 수를 만나면 멈춤
* 둘다 멈추면 서로 마커의 값을 교체함
* 왼쪽마커는 오른쪽으로 계속 진행하고 오른쪽 마커는 왼쪽 마커를 만날때까지 진행함 근데 오른쪽마커는 왼쪽 마커가 지나쳤다면 더이상 진행하지 않음 
* 오른쪽마커가 진행중에 왼쪽마커랑 만나면 종료후 마커랑 피벗이랑 교체
* 오른쪽마커가 끝에 도달하면 가자 큰수이니 피봇 위치를 -1 함
* 위 과정을 한번 진행하면 왼쪽, 오른쪽으로 나뉘는데 이를 다시 왼쪽에서 작업하고 오른쪽에서 작업함
* 모든 작업이 끝나면 정렬이 완료됨
* 특징
  * 시간복잡도 -> O(n^{2})
  * 최악의경우 O(N^2)
* 모든 작업이 끝나면 정렬이 완료됨우
* 모든 작업이 끝나면 정렬이 완료됨 
---
## [(읽어보기)퀵 정렬이 베스트가 아니다. quick vs merge vs heap - asfirstalways님의 티스토리](https://asfirstalways.tistory.com/338)
