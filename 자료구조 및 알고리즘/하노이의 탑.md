### 흐름
* ```java
  @Test
  public void solution() {
      Hanoi(5, 1, 3);
  }
* <img width="1236" height="200" alt="스크린샷 2022-01-18 오전 10 01 05" src="https://user-images.githubusercontent.com/51182964/149853137-7cf987b9-05cf-4bc9-9e79-2fdc5d724104.png">

* <img width="1254" height="200" alt="스크린샷 2022-01-18 오전 9 59 12" src="https://user-images.githubusercontent.com/51182964/149853142-8ae5db0f-9e9a-4598-913b-9b0926b50245.png">
* 점화식 (정화식으로 풀수있다면 이는 재귀로 표현될수있다.)
* ```java
  // hanoi(N, from, to, via) = 
  //          if(n==1) move(from, to)
  //          else hanoi(N-1, from, via, to) + move(from, to) + hanio(N-1, via, to, from)

---
### code
```java 

// ----------------------------------------------------------
// 기둥이 3개인 하노이의 탑에서 출발지에서 목적지로 이동할때 다음과 같은 규칙이 매번 적용된다.
// 1. 매번 적용된다는말의 의미는 재귀적으로 반복될수있다는것이다.
// 2. 매번 적용된다는말의 의미는 A -> B 로 가는 목적지든 A -> C 로 가든 목적지든 C -> A 로 가든 목적지든 전부 적용되는 규칙이라는 말이다.
//      즉, n번째의 디스크를 움직이기위해서 1 번째 디스크부터 n - 1 번째까지의 디스크를 옮기는 모든 과정들은 아래의 과정이 전부 적용된다는 의미다.
// 그래서 위의 과정중에 목적지에 따라서 목적지 외 디스크의 위치를 알아야하기 때문에 코드에서 int other = 6 - start - to; 를 사용한다.

// 과정 1. 나머지 모든 디스크를 목적지 외 디스크로 이동한다.
// 과정 2. 마지막 디스크를 목적지로 이동한다.
// 과정 3. 나머지 모든 디스크를 목적지 디스크로 이동 한다.
// ----------------------------------------------------------

// 디스크 1개
//      과정 1: 0번째를 목적지가 아닌 남는곳으로 이동 (생략)
//      과정 2: 1번째 디스크를 목적지로 이동 (O)
//      과정 3: 0번째 디스크를 목적지로 이동 (생략)

// 디스크 2개
//      과정 1: 1번째를 목적지가 아닌 남는곳으로 이동
//          디스크 1개 과정
//      과정 2: 2번째 디스크를 목적지로 이동
//          이동
//      과정 3: 1번째 디스크를 목적지로 이동
//          디스크 1개 과정

// 디스크 3개
//      과정 1: 2번째까지의 디스크를 목적지가 아닌 남는곳으로 이동
//          디스크 2개 과정
//      과정 2: 3번째 디스크를 목적지로 이동
//          이동
//      과정 3: 2번째까지의 디스크를 목적지로 이동
//          디스크 2개 과정

// 디스크 4개
//      과정 1: 3번째까지의 디스크를 목적지가 아닌 남는곳으로 이동
//          디스크 3개 과정
//      과정 2: 4번째 디스크를 목적지로 이동
//          이동
//      과정 3: 3번째까지의 디스크를 목적지로 이동
//          디스크 3개 과정

// 디스크 n개
//      과정 1: (n-1)번째까지의 디스크를 목적지가 아닌 남는곳으로 이동
//          디스크 (n-1)개 과정
//      과정 2: n번째 디스크를 목적지로 이동
//          이동
//      과정 3: (n-1)번째까지의 디스크를 목적지로 이동
//          디스크 (n-1)개 과정

// -----------------------------디테일 과정 ----------------------------------
// 디스크 1개
//      과정 1: 0번째를 목적지가 아닌 남는곳으로 이동 (생략)
//      과정 2: 1번째 디스크를 목적지로 이동 (O)
//      과정 3: 0번째 디스크를 목적지로 이동 (생략)

// 디스크 2개
//      과정 1: 1번째를 목적지가 아닌 남는곳으로 이동 (즉, 1번째까지의 디스크를 1 -> 2 으로 이동해야함)
//          1, 1, 2 (1번 째 디스크를 1 -> 2로 이동)
//      과정 2: 2번째 디스크를 목적지로 이동
//          2, 1, 3 (2번 째 디스크를 1 -> 3로 이동)
//      과정 3: 1번째 디스크를 목적지로 이동
//          1, 2, 3 (1번 째 디스크를 2 -> 3로 이동) (즉, 1번째까지의 디스크를 1 -> 3 으로 이동해야함)

// 디스크 3개
//      과정 1: 2번째까지의 디스크를 목적지가 아닌 남는곳으로 이동 (즉, 2번째까지의 디스크를 1 -> 2 으로 이동해야함)
//          과정 1: 1번째를 목적지가 아닌 남는곳으로 이동
//              1, 1, 3 (1번 째 디스크를 1 -> 3로 이동)
//          과정 2: 2번째 디스크를 목적지로 이동
//              2, 1, 2 (2번 째 디스크를 1 -> 2로 이동)
//          과정 3: 1번째 디스크를 목적지로 이동
//              1, 3, 2 (1번 째 디스크를 3 -> 2로 이동)
//      과정 2: 3번째 디스크를 목적지로 이동
//          3, 1, 3 (3번 째 디스크를 1 -> 3로 이동)
//      과정 3: 2번째까지의 디스크를 목적지로 이동  (즉, 2번째까지의 디스크를 1 -> 3 으로 이동해야함)
//          과정 1: 1번째를 목적지가 아닌 남는곳으로 이동
//              1, 2, 1 (1번 째 디스크를 2 -> 1로 이동)
//          과정 2: 2번째 디스크를 목적지로 이동
//              2, 2, 3 (2번 째 디스크를 2 -> 3로 이동)
//          과정 3: 1번째 디스크를 목적지로 이동
//              1, 1, 3 (1번 째 디스크를 1 -> 3로 이동)

void HanoisTop(int N, int start, int to){
    if(N==1){
        System.out.println("1번째 디스크를 " + start + " -> " + to);
    }

    // 해당 변수는 목적지가 변경되었기 때문에 사용한다. 즉, 목적지 외에 위치에 n-1 번째까지의 디스크를 옮겨야하기 때문에 사용한다. 목적지 외에 위치는 항상 2(가운데)가 아니라는 점을 명시해야한다. 그 이유는 다시 한번 말하지만 목적지가 매번 변경될수있기때문이다. 목적지가 변경이 되는 이유는 목적지가 아닌 위치에 디스크를 놓아야할때도 주석에서 말한 규칙이 적용되야 하기 때문이다.
    int other = 6 - start - to; // 시작지랑 목적지를 안다면 나머지 위치는 해당 수식을 통해 알수있다.
    HanoisTop(N-1, start, other); // 과정1: n-1 번째의 디스크를 시작점에서 목적지가 아닌 위치로 이동

    System.out.println(N+"번째 디스크를 " + start + " -> " + to); // 과정2: n-1 번째까지의 이동이 전부 완료되었다면 마지막 디스크 즉, n번째 디스크를 목적지로 이동

    HanoisTop(N-1, other, to); // 과정3: 이제 목적지외에 위치에 쌓인 n-1 개의 디스크들을 다시 목적지로 이동해야함
}
