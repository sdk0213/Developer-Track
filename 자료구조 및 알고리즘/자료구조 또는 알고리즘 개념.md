#### 그래프
* 정점과 간선으로 이루어진 자료구조
* 트리와는 다르다.
  * 부모 자식 관계의 개념 X
  * 정점마다 간선이 무조건있어야되는것이 아님

#### [BFS](https://github.com/sdk0213/Developer-Track/blob/master/자료구조%20및%20알고리즘/BFS_Matrix_LinkedList.md)
* 너비 우선 탐색
* 기본적으로 이미 방문한 정점을 다시 방문하지 않아야 함
* 시간복잡도
  * 인접 리스트로 표현된 그래프: O(V+E)
    * 적은 숫자의 간선에서 사용하기
  * 인접 행렬로 표현된 그래프: O(V^2)
    * 많은 숫자의 간선에서 사용하기
#### DFS
* 깊이 우선 탐새
* 기본적으로 이미 방문한 정점을 다시 방문하지 않아야 함
#### 그리디
* 최적의 해를 구하여 최선의 해를 구함
* 하지만 최선의 해는 결과적으로 반드시 정답이 아닐 가능성이 있기 때문에 문제 해결시 그리디로 풀수없다면 다른 방법을 강구해야한다. 예를들면 브루트포스..
#### 선형탐색
* 하나하나 앞에서부터 탐색
#### 이분탐색
* 반으로 나누어서 탐색
#### 해시맵
* 키를 해시로 변경하여 배열에 저장하여 O(1) 을 보장하는 맵
* 해시가 중복될경우 링크드 리스트형태로 구현되기때문에 O(n) 이 필요
#### HashSet
* 어떤 값이 존재하는지, 없는지 여부만 중요할 때 Set 을 사용한다.
#### 힙
* 완전 이진 트리의 일종
* 최대값과 최소값을 바로 찾을수 있다는 특징이 있다. 그 과정에서 완전이진트리를 사용하는것은 삽입/삭제 속도 때문이다.
* 간단히 말하면 부모 노드의 키 값이 자식 노드의 키 값보다 항상 큰(작은) 이진 트리를 말한다.
* 반정렬 상태(느슨한 정렬 상태) 이기 때문에 큰 값이 상위 레벨, 작은 값이 하위 레벨에 있기만 하면 힙을 만족한다. 그렇기 때문에 내 상위레벨은 아니지만 다른 상위레벨에는 나보다 작은값이 상위레벨에 존재할수도있다.
* 우선순위 큐(priority queue)를 구현하거나, 힙 정렬(heap sort)을 만드는 데 사용함
#### 스택
* LIFO(Last-In-First-Out) 방식
#### 큐
* FIFO(First in first out) 방식
