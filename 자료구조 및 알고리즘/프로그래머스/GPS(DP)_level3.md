# GPS
* [문제설명은 여기를 확인](https://programmers.co.kr/learn/courses/30/lessons/1837)
  * 요약하자면 택시기사가 움직일때 네트워크상의 문제로 GPS 로그가 부정확한 경우가 있을수도 있다. 그러니 이를 보정하고 또 최소한의 값으로 보정을 해라.
---
### 설명
* 아래설명은 이해가 안갈수있음
  * 문제설명을 최소한으로 보정해라 == GPS_LOG 랑 가장 비슷하게 이동해라(단 출발점과 도착점은 같다.)
  * 이해가 안간다면 이게 왜 DP 문제인지를 파악하면된다.
  * 결국 문제가원하는것은 5초(시간)에 7번 위치에 있었을때 최소한의 보정횟수 인데.. 이는 곧 4초(시간)에 5번과 6번 또는 그냥 머무는 경우의수(7번) 가 가진 최소한의 보정횟수에 + 5초 7번위치에서의 보정횟수인데...
  * 이는 4초에 5번이라면 3초에 3,5,6, 7번 위치에 있었던 최소한의 보정횟수중 가장 작은값을 의미하고 만약에 4초에 6번이라며 4,5,6,7 중 가장 최소한..
  * ... 이는 결국 최소한의 값으로 dp 를 채운다면 5번 7위치 값의 최소한의 보정횟수를 구할수있다는뜻이다.
  * 최소한의 보정횟수 + 최소한의 보정횟수 + ...... = 최소한의 보정횟수
  * [설명블로그](https://eno1993.tistory.com/80)
* gps_log 랑 최소한으로 값이 달라야 한다. 이를 이런식으로도 표현이 가능한데 만약에 GPS_LOG 가 같이 다음과 같을때를 따져보자
  * 1 -> 2 -> 3 -> 3 -> 6 -> 7
* 시간으로 따진다면 0초에 1번 위치에 있고 1초에 2번위치...5초에 7번 위치에 있었다라고 표현을 해보자.
* 그리고 이를 1초에 어디에 있느냐 또는 2초.. 3초.. 5초에 어디 위치에 있느냐에 따라서 GPS_LOG 랑 값이 달리질수있다.
* 만약에 내가 1초에 1번 위치에 있는다면 GPS_LOG 상에서 1초에 1번에 있었기 때문에 값이 같다.
* 2초의 경우에도 2초에 내가 1번에 있을수도 있고 2번..심지어 7번에도 있을수도 있다... 물론 불가능한 경우도 있지만 컴퓨터는 그런걸 모르기때문에 우선 다 따진다고 해보자.
* dp 를 하나 만들어보자.

* DP 를 이용해서 풀며.. 이를 생각한다는 과정이 매우매우 어려운것 같고 나도 다른사람 문제를 보고 간신히 이해를 해서 풀었다.
* dp 는 다음값을 의미한다.
  * dp[i][j]
  * i 는 현재 초(시간), j 는 현재 위치, 결과값은 GPS_LOG 가 i 초가 될때까지 GPS_LOG 랑 가장 최소한으로 값이 달랐던 경우의 수를 뜻한다.
* 우선 모든 값을 INF 로 초기화한다. 왜냐하며 아직 알수없기 때문이다.
* 이 문제가 원하는값을 dp[5][7] 째에 들어있다. 왜냐하면 dp[5][7]은 5초일때 7번 위치에 있을때 GPS_LOG 에서 0에서 5초동안 가장 최소한으로 값이 달랐던 경로이기 때문이다.
* 0초에 1번..2번..7번까지 있을수도 있지만 0초에 1번에만 있어야 하기 때문에 dp[0][1]은 값이 0 이다. 왜냐하면 출발지점과 종료지점은 똑같기 때문이다.
* 1초에 만약에 2번의 있는 경우의수를 따지면 이느 0초에 연결된부분에 있었던 경우 즉, 1번 3번 4번 그리고 그냥 머물렀던 경우의수.. 이 네가지 경우의수중 가장 작은값 + GPS_LOG 랑 다르면 +1 아니면 +0(변함없음) 을한다.
* 이런식으로 0초에서부터 5초까지 진행해서 모든 dp 를 따져보면 결과적으로 해당값은 정답이된다.
---
### 코드 
* ```java
  import java.util.*; 
  
  class Solution { 
    int INF = 99999999; 
    
    public int solution(int n, int m, int[][] edge_list, int k, int[] gps_log) { 
      int[][] road = new int[n+1][n+1]; 
      for(int i=0; i<edge_list.length; i++){ 
        int s = edge_list[i][0]; 
        int e = edge_list[i][1]; 
        int road[s][e] = 1; 
        int road[e][s] = 1;
      } 
      
      int[][] dp = new int[k][n+1]; 
      for(int i=0; i<k; i++){ 
        for(int j=0; j<n+1; j++){ 
          dp[i][j] = INF; 
        }
      } 
      
      dp[0][gps_log[0]] = 0;
      for(int i=1; i<k; i++){
        for(int j=1; j<n+1; j++){
          dp[i][j] = Math.min(dp[i][j], dp[i-1][j]);
          for(int node=1; node<n+1; node++){
            if(road[j][node]==1){
              dp[i][j] = Math.min(dp[i][j], dp[i-1][node]); 
            } 
          } 
          if(j!=gps_log[i]){ 
            dp[i][j]++; 
          }
        }
      } 
      
      if(dp[k-1][gps_log[k-1]]<INF){ 
        return dp[k-1][gps_log[k-1]]; 
      } else{ 
        return -1; 
      } 
    }
  }

출처: https://eno1993.tistory.com/80 [Develop Lab] 
