### 시간복잡도
* 빅오
  * 최악의 시간을 고려함
* 빅오 계산시 상수는 무시 
* ![image](https://user-images.githubusercontent.com/51182964/160604891-effa1125-13a9-4702-a537-de89ba4532b1.png)
* |표기|설명|
  |:--:|:--:|
  |O(1)|즉시|
  |O(logn)|O(1) 과 O(n) 사이로 Binary search 가 초반에 오래걸리는것같지만 금방 찾는것 같은 느낌의 시간이라고 보면된다.|
  |O(n)|시간에 따라 선형적으로 n 씩 증가|
  |O(n^2)|보통 for 문을 두개쓸경우 이와 같은 시간복잡도가 형성된다.(n^2, n^3 은 모두 n^2 로 표현.. 왜냐하면 느린건 거기서 거기라서|
  |O(2^n)|재귀(피보나치)가 대표젹이며 가장 최악의 시간이 소요된다.|

---
##### 완전탐색
* <img width="1339" alt="스크린샷 2022-04-26 오후 8 01 22" src="https://user-images.githubusercontent.com/51182964/165286126-f06e3a32-8e29-45c7-875a-1f9c11f6c214.png"> 
##### ArrayList
* 탐색
  * 어디에 있는지 인덱스로 알고있다? -> O(1)
  * 모른다? -> 하나씩 찾아봐야함 -> O(n)
* 제거 및 추가
  * 기본적으로 사이즈 변경되면 메모리 재할당이 일어나서 느림
  * 끝에서 삭제 및 추가 -> O(1)
  * 중간에서 삭제 및 추가 -> 중간뒤쪽 값들 다른 메모리에 저장 -> 값 삭제 및 추가 -> 다시 옮기기 -> 이과정에서 O(n) 소모됨
 
##### LinkedList
* 삽입 삭제에 유리하다고는 하나 
* 탐색
  * 어디에 있는지 인덱스로 알고있다? -> O(n) -> 왜냐하면 처음부터 탐색해서 메모리를 따라서 인덱스에 도달해야하기 때문에
  * 모른다? -> O(n)
* 제거 및 추가
  * 맨 앞, 맨 뒤 -> O(1)
  * 탐색을 통한 중간 삽입 -> O(n)


  
