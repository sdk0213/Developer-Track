### 시간복잡도
* 빅오
  * 최악의 시간을 고려함
* 빅오 계산시 상수는 무시 
* ![image](https://user-images.githubusercontent.com/51182964/160604891-effa1125-13a9-4702-a537-de89ba4532b1.png)
* |표기|설명|
  |:--:|:--:|
  |O(1)|즉시|
  |O(logn)|O(1) 과 O(n) 사이로 Binary search 가 초반에 오래걸리는것같지만 금방 찾는것 같은 느낌의 시간이라고 보면된다.|
  |O(n)|시간에 따라 선형적으로 n 씩 증가|
  |O(n^2)|보통 for 문을 두개쓸경우 이와 같은 시간복잡도가 형성된다.(n^2, n^3 은 모두 n^2 로 표현.. 왜냐하면 느린건 거기서 거기라서|
  |O(2^n)|재귀(피보나치)가 대표젹이며 가장 최악의 시간이 소요된다.|

---
##### 완전탐색
* <img width="1339" alt="스크린샷 2022-04-26 오후 8 01 22" src="https://user-images.githubusercontent.com/51182964/165286126-f06e3a32-8e29-45c7-875a-1f9c11f6c214.png"> 
##### ArrayList
* 탐색
  * 어디에 있는지 인덱스로 알고있다? -> O(1)
  * 모른다? -> 하나씩 찾아봐야함 -> O(n)
* 제거 및 추가
  * 기본적으로 사이즈 변경되면 메모리 재할당이 일어나서 느림
  * 끝에서 삭제 및 추가 -> O(1)
  * 중간에서 삭제 및 추가 -> 중간뒤쪽 값들 다른 메모리에 저장 -> 값 삭제 및 추가 -> 다시 옮기기 -> 이과정에서 O(n) 소모됨
 
##### LinkedList
* ![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FqDNZC%2FbtqTDcNc2nn%2FZr5Gw6XQiUZFxPAT62vftK%2Fimg.png)
* 데이터의 삽입/삭제가 빈번 할 경우 사용하면 ArrayList 에 비해 더 나은 성능을 보여준다(대량의 데이터일 경우에 해당함)
* 탐색
  * 어디에 있는지 인덱스로 알고있다? -> O(n) -> 왜냐하면 처음부터 탐색해서 메모리를 따라서 인덱스에 도달해야하기 때문에
  * 모른다? -> O(n)
* 제거 및 추가
  * 맨 앞, 맨 뒤 -> O(1)
  * 중간 삽입, 삭제 -> O(n)
    * O(1) 이 아닌 이유는 add/remove 를 하려는 항목까지 탐색을 해야하기 때문
  * 삽입 -> O(1)
  
##### LinkedList vs ArrayList
* ArrayList 가 메모리에 연속적으로 저장되기 때문에 속도가 더 빠른 경우도 있다.
* LinkedList 는 헤드와 테일에 대한 추가적인 메모리 공간이 필요하다.
* 일반적으로는 삽입/삭제가 많이 일어나면 LinkedList 를 사용 탐색이 많을 경우 ArrayList 를 사용하며 상황에 따라 다를것이라고 생각함
