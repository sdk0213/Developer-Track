# 안드로이드 캐싱 전략
* 기본 지식
  * 접근속도
    * 메모리 > IO
  * LRU (Least Recently Used)
    * 존재한다면 최근 위치로 이동
    * 없다면 최근 위치에 삽입
    * 사이즈를 초과시 가장 오랫동안 참조되지 않는 갑 삭제
    * 예
      * cache = [1, 2, 3, 4, 5]
      * 3을 넣음 : [1, 2, 4, 5, 3]
      * 7을 넣음 : [2, 4, 5, 3, 7]
      * 2는 넣음 : [4, 5, 3, 7, 2]
* 안드로이드 LruCache
  * LruCache는 제한된 사이즈에서 참조(set or get)된지 가장 오래된 객체를 제거해주는 데이터구조
  * ```kotlin
    @Test
    fun example1(){
        val cache = LruCache<String,Int>(5) // maxSize = 5
    
        cache.put("A",0) //[A]
        cache.put("B",0) //[A, B]
        cache.put("C",0) //[A, B, C]
        cache.put("D",0) //[A, B, C, D]
        cache.put("E",0) //[A, B, C, D, E] - A부터 E까지 캐싱 완료
        cache.put("F",0) //[B, C, D, E, F] - F를 캐싱하면, A는 제거됨
        cache.put("D",0) //[B, C, E, F, D] - D를 다시 캐싱하면 최근 참조된 상태로 변경
        cache.get("C") //[B, E, F, D, C] - C를 통해 캐시된 데이터 접근시 최근 참조된 상태로 변경
    }
* 메모리 캐시
  *  
* IO 캐시
  * 일반적으로 알고있는 캐시 저장소
    * /data/data/${PkgName}/cache 에 
    * 또는 외부저장소의 패키지별의 캐시
